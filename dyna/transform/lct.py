from arsenal import colors
from dyna import TransformedProgram, Derivation, Rule, Product, Term, fresh, covers, Var, unifies, unify, is_var
from dyna import syntax
from dyna.transform.slash import not_matches3


class LCT(TransformedProgram):

    def __init__(self,
                 program,
                 positions: 'Map from rules index to positions of the subgoal to slash from',
                 other_fn = '$other',
                 slash_fn = '/',
                 x = 'X',
    ):
        assert isinstance(positions, dict), positions

        if isinstance(x, str): x = syntax.term(x)

        # Below, we check that `slash_fn` and `other_fn` are unique symbols in
        # `program`.  (Note that this is stricter than necessary, what we need
        # is for the types generated by the slash to be disjoint with existing
        # types, e.g., (f(X)/foo) is distinct from (f(X)/goo) even though their
        # outer functors are the same.
        slash_fn = program._gen_functor(slash_fn)
        other_fn = program._gen_functor(other_fn)

        # x must have unique variables
        x = fresh(x)

        self.x = x
        self.positions = positions
        self.parent = program
        self.other_fn = other_fn
        self.slash_fn = slash_fn
        slash = self._slash; other = self._other

        self._parent_nodes = nodes = program.coarse_nodes()

        new_rs = []
        def add_rule(*xs):
            r = fresh(Rule(*xs))
            new_rs.append(r)
            return r

        # TODO: use a better data structure (e.g., union of nonground terms) to
        # represent this.
        useful_other = [self.x]
        for i, r in enumerate(program):
            j = self.positions.get(i)
            if j is not None:
                y = program.rules[i].body[j]
                if self.is_const(y) or self.is_builtin(y):
                    nodes.add(y)      # add to the set of nodes
                else:
                    useful_other.append(y)

        self._useful_other = useful_other

        # there are 6 kinds of rules: ss, oo, o, rso, ro, base
        self.ss = {}; self.rso = {}; self.ro = {}; self.o = {}; self.oo = {}

        y = Var('Tmp')
        self.base = add_rule(slash(y, y))

        for i, r in enumerate(program):

            j = positions.get(i)

            h = r.head; b = r.body

            if j is None:
                if self._is_useful_other(h):
                    self.o[i] = add_rule(other(h), *b)
                else:
                    # don't create useless `$other` items
                    self.o[i] = add_rule(h, *b)

                continue

            # Check conditions on position vector
            assert not unifies(x, r.body[j]) or covers(x, r.body[j])
            assert not len(r.body) == 0
            #assert not program.is_builtin(b[j]), b[j]
            #assert not program.is_const(b[j]), b[j]

            self.ss[i] = add_rule(slash(y, b[j]), *b[:j], *b[j+1:], slash(y, h))

            # What do speculation and left-corner have in common?
            # For all heads h in the slashed rules, we build h / x.#

            if not unifies(self.x, b[j]):
                self.oo[i] = add_rule(other(h), *b[:j], other(b[j]), *b[j+1:])

        # Below, we generate rules for each of the possible functors.  (This is
        # required for our trick which enables us to not label inputs with
        # other.)

        for y in nodes:

            if program.is_exogenous(y):
                continue

            y = fresh(y)

            if self._is_useful_other(y):
                for c in not_matches3(fresh(self.x), y):
                    self.ro[y] = add_rule(y, other(y), *c)

            for x in nodes:
                x = fresh(x)
                for _ in unify(self.x, x):
                    self.rso[y,x] = add_rule(y, other(x), slash(y, x))

        super().__init__(('lct', y), program, new_rs)

        # XXX: quick hack to put rule indices on rules...
        for i,r in enumerate(self):
            r._index = i

    def _slash(self, y, x):
        #assert not self.is_const(x), x
        return Term(self.slash_fn, y, x)

    def _other(self, x):
        # No need to wrap the input in other(...).  We don't need these
        # items because the item x that we are slashing out cannot appear in
        # an input's computation (bc no items can!).  In other words, a
        # little bit of program tidying would clean this up for us, but I'd
        # rather not make more of a mess than necessary.
        #assert not self.is_const(x), x
        if self.parent.is_exogenous(x):
            return x
        elif self._is_useful_other(x):
            return Term(self.other_fn, x)
        else:
            return x

    def _is_useful_other(self, x):
        return any(unifies(x, y) for y in self._useful_other)

    def transform(self, d):
        if isinstance(d, (tuple, list, Product)): return Product(map(self.transform, d))
        if Derivation.base(d): return d
        j = self.positions.get(d.i)
        coarsen = self._parent_nodes.root
        if j is None:

            # handle cases of useless others
            if self._is_useful_other(d.head):
                other = self.d(self.o[d.i]._index)(self._other(d.head), *self.transform(d.body))
                return self.d(None)(d.head, other)
            else:
                return self.d(None)(d.head, *self.transform(d.body))

        if not unifies(d.head, self.x):
#            return self.d(self.oo[d.i]._index)(d.head, *d.body.transform(self))
            return self.d(None)(d.head, *self.transform(d.body))

        x, spine = self.transform_spine(d, d, callback = lambda x: x)
        # Apply recovery rules to promote spine into an actual derivation of d.head

        if self.is_const(x):
            other = x
            [xxx] = x
        else:
            other = self.d(self.o[x.i]._index)(self._other(x.head), *self.transform(x.body))

            [xxx] = other.head.args
        return self.d(self.rso[coarsen(d.head), coarsen(xxx)]._index)(d.head, spine, other)

    def transform_spine(self, d, y, callback):
        j = self.positions.get(d.i) if not Derivation.base(d) else None
        if j is None:
            x = d
            return x, callback(self.d(self.base._index)(self._slash(y.head, y.head)))

        def callback1(xxx):
            return self.d(self.ss[d.i]._index)(
                self._slash(y.head, d.body[j].head if isinstance(d.body[j], Derivation) else d.body[j]),
                *self.transform(d.body[:j]),
                *self.transform(d.body[j+1:]),
                callback(xxx),
            )

        return self.transform_spine(d.body[j], y, callback1)
